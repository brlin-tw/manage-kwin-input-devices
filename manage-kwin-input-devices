#!/usr/bin/env bash
# Manage disable/enable state of input devices under Kwin(works under KDE Wayland)
#
# Copyright 2025 Amine Hassane
# Copyright 2025 林博仁(Buo-ren Lin) <buo.ren.lin@gmail.com>
# SPDX-License-Identifier: MIT

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

QDBUS="${QDBUS:-qdbus6}"

if ! set -eE; then
    printf 'Error: Unable to configure error handling.\n' 1>&2
    exit 2
fi

script_basecommand="${0}"
if test "${#}" -lt 1; then
    printf 'Usage: %s _operation_mode_ _operation_args_...\n' "${script_basecommand}" 1>&2
    exit 1
fi

# Query input device's sysfs name from it's display name
#
# Environment variables:
#
# * QDBUS: The qdbus-like external command to call
#
# Standard output: Sysfs name of the matched input device
# Supported return values:
#
# * 0: Matching device found
# * 1: Generic error
# * 2: No matching device found
get_input_device_sysfs_name(){
    local display_name="${1}"; shift

    local sysnames_raw
    if ! sysnames_raw="$(
        "${QDBUS:-qdbus}" \
            org.kde.KWin \
            /org/kde/KWin/InputDevice \
            org.freedesktop.DBus.Properties.Get \
            org.kde.KWin.InputDeviceManager \
            devicesSysNames
        )"; then
        printf 'Error: Unable to query the sysfs names of the kwin input devices.\n' 1>&2
        return 1
    fi

    if ! mapfile -t sysnames <<<"${sysnames_raw}"; then
        printf 'Error: Unable to load the sysnames array.\n' 1>&2
        return 1
    fi

    for sysname in "${sysnames[@]}"; do
        if ! name="$(
            "${QDBUS:-qdbus}" \
                org.kde.KWin \
                "/org/kde/KWin/InputDevice/${sysname}" \
                org.freedesktop.DBus.Properties.Get \
                org.kde.KWin.InputDevice \
                name
            )"; then
            printf \
                'Error: Unable to query the display name of the "%s" input device.\n' \
                "${sysname}" \
                1>&2
            return 1
        fi

        if test "${display_name}" == "${name}"; then
            # Matching device found
            echo "${sysname}"
            return 0
        fi
    done

    # No matching device found
    return 2
}

# List input devices managed by kwin
list_devices() {
    local sysnames_raw
    if ! sysnames_raw="$(
        "${QDBUS:-qdbus}" \
            org.kde.KWin \
            /org/kde/KWin/InputDevice \
            org.freedesktop.DBus.Properties.Get \
            org.kde.KWin.InputDeviceManager \
            devicesSysNames
        )"; then
        printf 'Error: Unable to query the sysfs names of the kwin input devices.\n' 1>&2
        return 1
    fi

    if ! mapfile -t sysnames <<<"${sysnames_raw}"; then
        printf 'Error: Unable to load the sysnames array.\n' 1>&2
        return 1
    fi

    printf 'enabled?\tsysfs name\t"display name"\n'
    for sysname in "${sysnames[@]}"; do
        if ! name="$(
            "${QDBUS:-qdbus}" \
                org.kde.KWin \
                "/org/kde/KWin/InputDevice/${sysname}" \
                org.freedesktop.DBus.Properties.Get \
                org.kde.KWin.InputDevice \
                name
            )"; then
            printf \
                'Error: Unable to query the display name of the "%s" input device.\n' \
                "${sysname}" \
                1>&2
            return 1
        fi

        if ! enabled="$(is_input_device_enabled "${sysname}")"; then
            printf 'Error: Unable to query the enabled status of the "%s" input device.' "${sysname}" 1>&2
            return 1
        fi

        # NOTE: The bash built-in printf doesn't not print pretty quoted strings, use the one from coreutils instead.
        env printf '%s\t\t%s\t\t%q\n' "${enabled}" "${sysname}" "${name}"
    done
}

# Determine whether the specified input device is enabled
#
# Standard output:
#
# * "true": The input device is enabled
# * "false": The input device is not enabled
#
# Return values:
#
# * 0: Operation successful
# * 2: Generic error
is_input_device_enabled(){
    local device="${1}"; shift

    local sysfs_name
    if ! is_input_device_sysfs_name "${device}"; then
        if ! sysfs_name="$(get_input_device_sysfs_name "${device}")"; then
            printf \
                'Error: Unable to query the sysfs name of the "%s" input device.\n' \
                "${device}" \
                1>&2
            return 2
        fi
    else
        sysfs_name="${device}"
    fi

    local result
    if ! result="$(
        "${QDBUS:-qdbus}" \
            org.kde.KWin \
            "/org/kde/KWin/InputDevice/${sysfs_name}" \
            org.freedesktop.DBus.Properties.Get \
                org.kde.KWin.InputDevice \
                enabled
        )"; then
        printf \
            'Error: Unable to call the qdbus command to query the enabled status for the "%s" input device.\n' \
            "${device}" \
            1>&2
        return 2
    fi

    case "${result}" in
        true|false)
            # Result is the same so simply echo them
            printf '%s' "${result}"
        ;;
        *)
            printf \
                'Error: Unexpected output(%s) from the dbus call.\n' \
                "${result}" \
                1>&2
            return 2
        ;;
    esac
}

# Set the input device's enabled status
#
# Positional parameters:
#
# 1. sysname: The sysfs name of the input device to query status, e.g.: event2
# 2. state: The desired state of the input device to set:
#     + `true`: Input device is enabled
#     + `false`: Input device is not enabled
set_device_status() {
    local sysname="${1}"; shift
    local state="${1}"; shift

    "${QDBUS:-qdbus}" org.kde.KWin "/org/kde/KWin/InputDevice/${sysname}" org.freedesktop.DBus.Properties.Set org.kde.KWin.InputDevice enabled "${state}"
}

# Enable the specified input device if it's not enabled, and vice versa.
#
# Return values:
#
# * 0: Operation successful.
# * 2: Generic error.
toggle_device() {
    # The sysfs or display name of the input device to toggle the enabled status, e.g.: event2
    local device="${1}"; shift

    local enabled
    if ! enabled="$(is_input_device_enabled "${device}")"; then
        printf 'Error: Unable to query the enabled status of the "%s" input device.' "${device}" 1>&2
        return 2
    fi

    case "${enabled}" in
        true)
            if ! disable_device "${device}"; then
                printf \
                    'Error: Unable to disable the "%s" device.\n' \
                    "${device}" \
                    1>&2
                return 2
            fi
        ;;
        false)
            if ! enable_device "${device}"; then
                printf \
                    'Error: Unable to enable the "%s" device.\n' \
                    "${device}" \
                    1>&2
                return 2
            fi
        ;;
        *)
            printf \
                '%s: FATAL: Unsupported value of the enabled variable(%s)\n.' \
                "${FUNCNAME[0]}" \
                "${enabled}" \
                1>&2
            exit 99
        ;;
    esac
    return 0
}

# Determine whether the supplied string is a sysfs name of a input device
#
# Return values:
#
# * 0: Is sysfs name
# * 1: Not sysfs name
is_input_device_sysfs_name(){
    local device="${1}"; shift

    local regex_sysfs_names='^event[[:digit:]]+$'
    if [[ "${device}" =~ ${regex_sysfs_names} ]]; then
        return 0
    else
        return 1
    fi
}

# Enable a input device by its sysfs name or its display name
#
# Return values:
#
# * 0: Operation successful
# * 2: Generic error
enable_device(){
    local device="${1}"; shift

    if ! is_input_device_sysfs_name "${device}"; then
        if ! sysfs_name="$(get_input_device_sysfs_name "${device}")"; then
            printf \
                'Error: Unable to query the sysfs name of the "%s" input device.\n' \
                "${device}" \
                1>&2
            return 2
        fi
    else
        sysfs_name="${device}"
    fi

    if ! set_device_status "${sysfs_name}" true; then
        printf \
            'Error: Unable to enable the "%s" input device.\n' \
            "${device}" \
            1>&2
        return 2
    fi

    return 0
}

# Disable a input device by its sysfs name or its display name
#
# Return values:
#
# * 0: Operation successful
# * 2: Generic error
disable_device(){
    local device="${1}"; shift

    if ! is_input_device_sysfs_name "${device}"; then
        if ! sysfs_name="$(get_input_device_sysfs_name "${device}")"; then
            printf \
                'Error: Unable to query the sysfs name of the "%s" input device.\n' \
                "${device}" \
                1>&2
            return 2
        fi
    else
        sysfs_name="${device}"
    fi

    if ! set_device_status "${sysfs_name}" false; then
        printf \
            'Error: Unable to disable the "%s" input device.\n' \
            "${device}" \
            1>&2
        return 2
    fi

    return 0
}

operation_mode="${1}"; shift 1
case "${operation_mode}" in
    enable)
        if test "${#}" -eq 0; then
            printf \
                'Usage: %s enable _input_device_...\n' \
                "${script_basecommand}" \
                1>&2
            printf \
                '\n_input_device_ can be its sysfs name or display name.\n' \
                1>&2
            exit 1
        fi

        devices=("${@}")
        for device in "${devices[@]}"; do
            if ! enable_device "${device}"; then
                printf \
                    'Error: Unable to enable the "%s" input device.\n' \
                    "${device}" \
                    1>&2
                exit 2
            fi
        done
    ;;
    disable)
        if test "${#}" -eq 0; then
            printf \
                'Usage: %s disable _input_device_...\n' \
                "${script_basecommand}" \
                1>&2
            printf \
                '\n_input_device_ can be its sysfs name or display name.\n' \
                1>&2
            exit 1
        fi

        devices=("${@}")
        for device in "${devices[@]}"; do
            if ! disable_device "${device}"; then
                printf \
                    'Error: Unable to disable the "%s" input device.\n' \
                    "${device}" \
                    1>&2
                exit 2
            fi
        done
    ;;
    toggle)
        if test "${#}" -eq 0; then
            printf \
                'Usage: %s toggle _input_device_...\n' \
                "${script_basecommand}" \
                1>&2
            printf \
                '\n_input_device_ can be its sysfs name or display name.\n' \
                1>&2
            exit 1
        fi

        devices=("${@}")
        for device in "${devices[@]}"; do
            if ! toggle_device "${device}"; then
                printf \
                    'Error: Unable to toggle the enabled state the "%s" input device.\n' \
                    "${device}" \
                    1>&2
                exit 2
            fi
        done
    ;;
    # Display enabled status for specified input device(s)
    status)
        if test "${#}" -eq 0; then
            printf \
                'Usage: %s status _input_device_...\n' \
                "${script_basecommand}" \
                1>&2
            printf \
                '\n_input_device_ can be its sysfs name or display name.\n' \
                1>&2
            exit 1
        fi

        enabled=
        devices=("${@}")
        if test "${#devices[@]}" -eq 1; then
            device="${devices[0]}"
            if ! enabled="$(is_input_device_enabled "${device}")"; then
                printf 'Error: Unable to query the enabled status of the "%s" input device.' "${enabled}" 1>&2
                exit 2
            fi

            # We only print [enabled|disabled] when only one device is specified for the ease of scripting
            if test "${enabled}" == true; then
                printf 'disabled\n'
            else
                printf 'enabled\n'
            fi
        else
            for device in "${devices[@]}"; do
                if ! enabled="$(is_input_device_enabled "${device}")"; then
                    printf 'Error: Unable to query the enabled status of the "%s" input device.' "${enabled}" 1>&2
                    exit 2
                fi

                if ! enabled="$(is_input_device_enabled "${device}")"; then
                    state=disabled
                else
                    state=enabled
                fi

                printf '%s: %s\n' "${device}" "${state}"
            done
        fi
    ;;
    list)
        if ! list_devices; then
            printf \
                'Error: Unable to list kwin-managed input devices.\n' \
                1>&2
            exit 2
        fi
    ;;
    *)
        printf 'Error: Unsupported operation mode "%s".\n' "${operation_mode}" 1>&2
        exit 1
    ;;
esac

# We really want that output to be parsed easily
if test "${operation_mode}" != status; then
    printf 'Info: Operation completed without errors.\n'
fi
