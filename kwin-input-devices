#!/usr/bin/env bash
# Manage disable/enable state of input devices under Kwin(works under KDE Wayland)
#
# Copyright 2025 Amine Hassane
# Copyright 2025 林博仁(Buo-ren Lin) <buo.ren.lin@gmail.com>
# SPDX-License-Identifier: MIT

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

QDBUS="${QDBUS:-qdbus6}"

declare -A DEVICES_TO_BE_MANAGED=(
    ["asus_numpad"]=''
    ["ASUE140D:00 04F3:31B9 Touchpad"]=''
    ["AT Translated Set 2 keyboard"]=''
    ["PIXA3854:00 093A:0274 Touchpad"]=''
)

if ! set -eE; then
    printf 'Error: Unable to configure error handling.\n' 1>&2
    exit 2
fi

script_basecommand="${0}"
if test "${#}" != 1; then
    printf 'Usage: %s _operation_mode_\n' "${script_basecommand}" 1>&2
    exit 1
fi

# Query input device's sysfs name from it's display name
#
# Environment variables
# Standard output: Sysfs name of the matched input device
# Supported return values:
#
# * 0: Matching device found
# * 1: Generic error
# * 2: No matching device found
get_input_device_sysfs_name(){
    local display_name="${1}"; shift

    local sysnames_raw
    if ! sysnames_raw="$(
        "${QDBUS:-qdbus}" \
            org.kde.KWin \
            /org/kde/KWin/InputDevice \
            org.freedesktop.DBus.Properties.Get \
            org.kde.KWin.InputDeviceManager \
            devicesSysNames
        )"; then
        printf 'Error: Unable to query the sysfs names of the kwin input devices.\n' 1>&2
        return 1
    fi

    if ! mapfile -t sysnames <<<"${sysnames_raw}"; then
        printf 'Error: Unable to load the sysnames array.\n' 1>&2
        return 1
    fi

    for sysname in "${sysnames[@]}"; do
        if ! name="$(
            "${QDBUS:-qdbus}" \
                org.kde.KWin \
                "/org/kde/KWin/InputDevice/${sysname}" \
                org.freedesktop.DBus.Properties.Get \
                org.kde.KWin.InputDevice \
                name
            )"; then
            printf \
                'Error: Unable to query the display name of the "%s" input device.\n' \
                "${sysname}" \
                1>&2
            return 1
        fi

        if test "${display_name}" == "${name}"; then
            # Matching device found
            echo "${sysname}"
            return 0
        fi
    done

    # No matching device found
    return 2
}

# Check existence of the DEVICES_TO_BE_MANAGED input devices in the running system, and, save their corresponding sysfs device name for future usage
find_devices() {
    local sysnames_raw
    if ! sysnames_raw="$(
        "${QDBUS:-qdbus}" \
            org.kde.KWin \
            /org/kde/KWin/InputDevice \
            org.freedesktop.DBus.Properties.Get \
            org.kde.KWin.InputDeviceManager \
            devicesSysNames
        )"; then
        printf 'Error: Unable to query the sysfs names of the kwin input devices.\n' 1>&2
        return 1
    fi

    if ! mapfile -t sysnames <<<"${sysnames_raw}"; then
        printf 'Error: Unable to load the sysnames array.\n' 1>&2
        return 1
    fi

    for sysname in "${sysnames[@]}"; do
        if ! name="$(
            "${QDBUS:-qdbus}" \
                org.kde.KWin \
                "/org/kde/KWin/InputDevice/${sysname}" \
                org.freedesktop.DBus.Properties.Get \
                org.kde.KWin.InputDevice \
                name
            )"; then
            printf \
                'Error: Unable to query the display name of the "%s" input device.\n' \
                "${sysname}" \
                1>&2
            return 1
        fi

        for device in "${!DEVICES_TO_BE_MANAGED[@]}"; do
            if [ "$name" == "$device" ]; then
                DEVICES_TO_BE_MANAGED["$device"]="$sysname"
            fi
        done
    done
}

# List input devices managed by kwin
list_devices() {
    local sysnames_raw
    if ! sysnames_raw="$(
        "${QDBUS:-qdbus}" \
            org.kde.KWin \
            /org/kde/KWin/InputDevice \
            org.freedesktop.DBus.Properties.Get \
            org.kde.KWin.InputDeviceManager \
            devicesSysNames
        )"; then
        printf 'Error: Unable to query the sysfs names of the kwin input devices.\n' 1>&2
        return 1
    fi

    if ! mapfile -t sysnames <<<"${sysnames_raw}"; then
        printf 'Error: Unable to load the sysnames array.\n' 1>&2
        return 1
    fi

    printf 'enabled?\tsysfs name\t"display name"\n'
    for sysname in "${sysnames[@]}"; do
        if ! name="$(
            "${QDBUS:-qdbus}" \
                org.kde.KWin \
                "/org/kde/KWin/InputDevice/${sysname}" \
                org.freedesktop.DBus.Properties.Get \
                org.kde.KWin.InputDevice \
                name
            )"; then
            printf \
                'Error: Unable to query the display name of the "%s" input device.\n' \
                "${sysname}" \
                1>&2
            return 1
        fi

        if ! status="$(get_device_status "${sysname}")"; then
            printf 'Error: Unable to query the enabled status of the "%s" input device.' "${sysname}" 1>&2
            return 1
        fi

        # NOTE: The bash built-in printf doesn't not print pretty quoted strings, use the one from coreutils instead.
        env printf '%s\t\t%s\t\t%q\n' "${status}" "${sysname}" "${name}"
    done
}

# Query the input device's enabled status
#
# Standard output:
#
# * `true`: Input device is enabled
# * `false`: Input device is not enabled
#
# Positional parameters:
#
# 1. sysname: The sysfs name of the input device to query status, e.g.: event2
get_device_status() {
    local sysname="${1}"; shift

    "${QDBUS:-qdbus}" org.kde.KWin "/org/kde/KWin/InputDevice/${sysname}" org.freedesktop.DBus.Properties.Get org.kde.KWin.InputDevice enabled
}

# Set the input device's enabled status
#
# Positional parameters:
#
# 1. sysname: The sysfs name of the input device to query status, e.g.: event2
# 2. state: The desired state of the input device to set:
#     + `true`: Input device is enabled
#     + `false`: Input device is not enabled
set_device_status() {
    local sysname="${1}"; shift
    local state="${1}"; shift

    "${QDBUS:-qdbus}" org.kde.KWin "/org/kde/KWin/InputDevice/${sysname}" org.freedesktop.DBus.Properties.Set org.kde.KWin.InputDevice enabled "${state}"
}

# Enable the specified input device if it's not enabled, and vice versa
# Positional parameters:
#
# 1. sysname: The sysfs name of the input device to query status, e.g.: event2
toggle_device() {
    local sysname="${1}"; shift

    if ! status="$(get_device_status "${sysname}")"; then
        printf 'Error: Unable to query the enabled status of the "%s" input device.' "${sysname}" 1>&2
        return 1
    fi

    case "${status}" in
        true)
            new_status=false
        ;;
        false)
            new_status=true
        ;;
        *)
            printf \
                '%s: Error: Unsupported value of the status variable(%s)\n.' \
                "${FUNCNAME[0]}" \
                "${status}" \
                1>&2
            exit 99
        ;;
    esac

    if ! set_device_status "${sysname}" "${new_status}"; then
        printf \
            'Error: Unable to set the new status(%s) of the "%s" input device.\n' \
            "${new_status}" \
            "${sysname}" \
            1>&2
        return 1
    fi
}

if ! find_devices; then
    printf 'Error: Unable to find the input devices to manage.\n' 1>&2
    exit 2
fi

operation_mode="${1}"
case "${operation_mode}" in
    enable)
        for device in "${!DEVICES_TO_BE_MANAGED[@]}"; do
            sysname=${DEVICES_TO_BE_MANAGED["$device"]}
            if test -z "${sysname}"; then
                continue
            fi

            if ! set_device_status "$sysname" true; then
                printf \
                    'Error: Unable to enable the "%s" input device.\n' \
                    "${sysname}" \
                    1>&2
                exit 2
            fi
        done
    ;;
    disable)
        for device in "${!DEVICES_TO_BE_MANAGED[@]}"; do
            sysname=${DEVICES_TO_BE_MANAGED["$device"]}
            if test -z "${sysname}"; then
                continue
            fi

            if ! set_device_status "$sysname" false; then
                printf \
                    'Error: Unable to disable the "%s" input device.\n' \
                    "${sysname}" \
                    1>&2
                exit 2
            fi
        done
    ;;
    toggle)
        for device in "${!DEVICES_TO_BE_MANAGED[@]}"; do
            sysname=${DEVICES_TO_BE_MANAGED["$device"]}
            if test -z "${sysname}"; then
                continue
            fi

            if ! toggle_device "$sysname"; then
                printf \
                    'Error: Unable to toggle the enabled status of the "%s" input device.\n' \
                    "${sysname}" \
                    1>&2
                exit 2
            fi
        done
    ;;
    status)
        for device in "${!DEVICES_TO_BE_MANAGED[@]}"; do
            sysname=${DEVICES_TO_BE_MANAGED["$device"]}
            if test -z "${sysname}"; then
                continue
            fi

            if ! status="$(get_device_status "$sysname")"; then
                printf \
                    'Error: Unable to query the enabled status of the "%s" input device.\n' \
                    "${sysname}" \
                    1>&2
                exit 2
            fi

            printf '%s: %s\n' "${device}" "${status}"
        done
    ;;
    list)
        if ! list_devices; then
            printf \
                'Error: Unable to list kwin-managed input devices.\n' \
                1>&2
            exit 2
        fi
    ;;
    *)
        printf 'Error: Unsupported operation mode "%s".\n' "${operation_mode}" 1>&2
        exit 1
    ;;
esac

printf 'Info: Operation completed without errors.\n'
